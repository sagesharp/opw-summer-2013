From f8f0d0942f044017abd4aba2f3e846675c5bc5dd Mon Sep 17 00:00:00 2001
From: Xenia Ragiadakou <burzalodowa@gmail.com>
Date: Tue, 30 Jul 2013 19:49:16 +0300
Subject: [PATCH] xhci: add xhci_ctx and xhci_cmd trace events

This patch adds xhci_address_ctx tracepoints in xhci_address_device()
in places where there is a call to xhci_dbg_ctx().
This tracepoint will print the entire context (control, slot and
endpoint contexts) when the xhci plugin is loaded.

Also, this patch adds an xhci_cmd tracepoint in handle_cmd_completion()
which will print the command completion event fields as well as the
associated command's TRB fields, if the xhci plugin is loaded.

Signed-off-by: Xenia Ragiadakou <burzalodowa@gmail.com>
---
 drivers/usb/host/xhci-ring.c  |  3 ++
 drivers/usb/host/xhci-trace.h | 70 +++++++++++++++++++++++++++++++++++++++++++
 drivers/usb/host/xhci.c       |  4 +++
 3 files changed, 77 insertions(+)

diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c
index 1e57eaf..a0c08ad 100644
--- a/drivers/usb/host/xhci-ring.c
+++ b/drivers/usb/host/xhci-ring.c
@@ -67,6 +67,7 @@
 #include <linux/scatterlist.h>
 #include <linux/slab.h>
 #include "xhci.h"
+#include "xhci-trace.h"
 
 static int handle_cmd_in_cmd_wait_list(struct xhci_hcd *xhci,
 		struct xhci_virt_device *virt_dev,
@@ -1377,6 +1378,8 @@ static void handle_cmd_completion(struct xhci_hcd *xhci,
 		return;
 	}
 
+	trace_xhci_cmd(&xhci->cmd_ring->dequeue->generic, event);
+
 	if ((GET_COMP_CODE(le32_to_cpu(event->status)) == COMP_CMD_ABORT) ||
 		(GET_COMP_CODE(le32_to_cpu(event->status)) == COMP_CMD_STOP)) {
 		/* If the return value is 0, we think the trb pointed by
diff --git a/drivers/usb/host/xhci-trace.h b/drivers/usb/host/xhci-trace.h
index 432aa67..92e3a01 100644
--- a/drivers/usb/host/xhci-trace.h
+++ b/drivers/usb/host/xhci-trace.h
@@ -18,6 +18,7 @@
 #define __XHCI_TRACE_H
 
 #include <linux/tracepoint.h>
+#include "xhci.h"
 
 #define XHCI_MSG_MAX	500
 
@@ -36,6 +37,75 @@ DEFINE_EVENT(xhci_log_msg, xhci_dbg_address,
 	TP_ARGS(vaf)
 );
 
+DECLARE_EVENT_CLASS(xhci_log_ctx,
+	TP_PROTO(struct xhci_hcd *xhci, struct xhci_container_ctx *ctx,
+		 unsigned int ep_num),
+	TP_ARGS(xhci, ctx, ep_num),
+	TP_STRUCT__entry(
+		__field(int, ctx_64)
+		__field(unsigned, ctx_type)
+		__field(dma_addr_t, ctx_dma)
+		__field(u8 *, ctx_va)
+		__field(unsigned, ctx_ep_num)
+		__field(int, slot_id)
+		__dynamic_array(u32, ctx_data,
+			((HCC_64BYTE_CONTEXT(xhci->hcc_params) + 1) * 8) *
+			((ctx->type == XHCI_CTX_TYPE_INPUT) + ep_num + 1))
+	),
+	TP_fast_assign(
+		struct usb_device *udev;
+
+		udev = to_usb_device(xhci_to_hcd(xhci)->self.controller);
+		__entry->ctx_64 = HCC_64BYTE_CONTEXT(xhci->hcc_params);
+		__entry->ctx_type = ctx->type;
+		__entry->ctx_dma = ctx->dma;
+		__entry->ctx_va = ctx->bytes;
+		__entry->slot_id = udev->slot_id;
+		__entry->ctx_ep_num = ep_num;
+		memcpy(__get_dynamic_array(ctx_data), ctx->bytes,
+			((HCC_64BYTE_CONTEXT(xhci->hcc_params) + 1) * 32) *
+			((ctx->type == XHCI_CTX_TYPE_INPUT) + ep_num + 1));
+	),
+	TP_printk("\nctx_64=%d, ctx_type=%u, ctx_dma=@%08llx, ctx_va=@%p",
+		  __entry->ctx_64, __entry->ctx_type, __entry->ctx_dma,
+		  __entry->ctx_va
+	)
+);
+
+DEFINE_EVENT(xhci_log_ctx, xhci_address_ctx,
+	TP_PROTO(struct xhci_hcd *xhci, struct xhci_container_ctx *ctx,
+		 unsigned int ep_num),
+	TP_ARGS(xhci, ctx, ep_num)
+);
+
+DECLARE_EVENT_CLASS(xhci_log_cmd,
+	TP_PROTO(void *cmd_trb_va, struct xhci_event_cmd *compl_event),
+	TP_ARGS(cmd_trb_va, compl_event),
+	TP_STRUCT__entry(
+		__field(void *, va)
+		__field(u64, dma)
+		__field(u32, status)
+		__field(u32, flags)
+		__dynamic_array(__le32, cmd_trb, 4)
+	),
+	TP_fast_assign(
+		__entry->va = cmd_trb_va;
+		__entry->dma = le64_to_cpu(compl_event->cmd_trb);
+		__entry->status = le32_to_cpu(compl_event->status);
+		__entry->flags = le32_to_cpu(compl_event->flags);
+		memcpy(__get_dynamic_array(cmd_trb), cmd_trb_va,
+		       sizeof(struct xhci_generic_trb));
+	),
+	TP_printk("\ncmd_dma=@%08llx, cmd_va=@%p, status=%08x, flags=%08x",
+		  __entry->dma, __entry->va, __entry->status, __entry->flags
+	)
+);
+
+DEFINE_EVENT(xhci_log_cmd, xhci_cmd,
+	TP_PROTO(void *cmd_trb_va, struct xhci_event_cmd *compl_event),
+	TP_ARGS(cmd_trb_va, compl_event)
+);
+
 #endif /* __XHCI_TRACE_H */
 
 /* this part must be outside header guard */
diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c
index 081b5b5..8668e30 100644
--- a/drivers/usb/host/xhci.c
+++ b/drivers/usb/host/xhci.c
@@ -3707,6 +3707,7 @@ int xhci_address_device(struct usb_hcd *hcd, struct usb_device *udev)
 
 	xhci_dbg(xhci, "Slot ID %d Input Context:\n", udev->slot_id);
 	xhci_dbg_ctx(xhci, virt_dev->in_ctx, 2);
+	trace_xhci_address_ctx(xhci, virt_dev->in_ctx, 1);
 
 	spin_lock_irqsave(&xhci->lock, flags);
 	cmd_trb = xhci->cmd_ring->dequeue;
@@ -3763,6 +3764,7 @@ int xhci_address_device(struct usb_hcd *hcd, struct usb_device *udev)
 				"code 0x%x.\n", virt_dev->cmd_status);
 		xhci_dbg(xhci, "Slot ID %d Output Context:\n", udev->slot_id);
 		xhci_dbg_ctx(xhci, virt_dev->out_ctx, 2);
+		trace_xhci_address_ctx(xhci, virt_dev->out_ctx, 1);
 		ret = -EINVAL;
 		break;
 	}
@@ -3781,8 +3783,10 @@ int xhci_address_device(struct usb_hcd *hcd, struct usb_device *udev)
 			(unsigned long long)virt_dev->out_ctx->dma);
 	xhci_dbg(xhci, "Slot ID %d Input Context:\n", udev->slot_id);
 	xhci_dbg_ctx(xhci, virt_dev->in_ctx, 2);
+	trace_xhci_address_ctx(xhci, virt_dev->in_ctx, 1);
 	xhci_dbg(xhci, "Slot ID %d Output Context:\n", udev->slot_id);
 	xhci_dbg_ctx(xhci, virt_dev->out_ctx, 2);
+	trace_xhci_address_ctx(xhci, virt_dev->out_ctx, 1);
 	/*
 	 * USB core uses address 1 for the roothubs, so we add one to the
 	 * address given back to us by the HC.
-- 
1.8.3.2

